Aspect: a modularization of a concern that cuts across multiple classes. Transaction management is a good example of a crosscutting concern in J2EE applications. In Spring AOP, aspects are implemented using regular classes (the schema-based approach) or regular classes annotated with the @Aspect annotation (the @AspectJ style).
Join point: a point during the execution of a program, such as the execution of a method or the handling of an exception. In Spring AOP, a join point always represents a method execution.
Advice: action taken by an aspect at a particular join point. Different types of advice include "around," "before" and "after" advice. Spring model an advice as an interceptor, maintaining a chain of interceptors around the join point.
Pointcut: a predicate that matches join points. Advice is associated with a pointcut expression and runs at any join point matched by the pointcut (for example, the execution of a method with a certain name). The concept of join points as matched by pointcut expressions is central to AOP, and Spring uses the AspectJ pointcut expression language by default.
Introduction: declaring additional methods or fields on behalf of a type. Spring AOP allows you to introduce new interfaces (and a corresponding implementation) to any advised object. For example, you could use an introduction to make a bean implement an IsModified interface, to simplify caching. (An introduction is known as an inter-type declaration in the AspectJ community.)
Target object: object being advised by one or more aspects. Also referred to as the advised object. Since Spring AOP is implemented using runtime proxies, this object will always be a proxied object.
AOP proxy: an object created by the AOP framework in order to implement the aspect contracts (advise method executions and so on). In the Spring Framework, an AOP proxy will be a JDK dynamic proxy or a CGLIB proxy.
Weaving: linking aspects with other application types or objects to create an advised object. This can be done at compile time (using the AspectJ compiler, for example), load time, or at runtime. Spring AOP, like other pure Java AOP frameworks, performs weaving at runtime.




Before Advice: These advices runs before the execution of join point methods. Here, we can use @Before annotation.
After (finally) Advice: An advice that gets executed after the join point method finishes executing, whether normally or by throwing an exception. Here, we can use @After annotation.
After Returning Advice: This advice gets execute only if the join point method executes normally. Here,  we can use @AfterReturning annotation.
After Throwing Advice: This advice gets executed only when join point method throws exception, we can use it to rollback the transaction declaratively. We use @AfterThrowing annotation here.
Around Advice: This is the most important and powerful advice. This advice surrounds the join point method and we can also choose whether to execute the join point method or not. We can write advice code that gets executed before and after the execution of the join point method. It is the responsibility of around advice to invoke the join point method and return values if the method is returning something. We use @Around annotation to create around advice methods.




 <dependencies>
        <!-- https://mvnrepository.com/artifact/org.springframework/spring-aop -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-aop</artifactId>
            <version>5.2.23.RELEASE</version>
        </dependency>
        <!-- https://mvnrepository.com/artifact/org.springframework/spring-core -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-core</artifactId>
            <version>5.2.23.RELEASE</version>
        </dependency>
        <!-- https://mvnrepository.com/artifact/org.springframework/spring-context -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>5.2.23.RELEASE</version>
        </dependency>
    </dependencies>







<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>AOPPrj1</artifactId>
    <version>1.0-SNAPSHOT</version>
    <dependencies>
        <!-- https://mvnrepository.com/artifact/org.springframework/spring-aop -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-aop</artifactId>
            <version>5.2.23.RELEASE</version>
        </dependency>
        <!-- https://mvnrepository.com/artifact/org.springframework/spring-core -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-core</artifactId>
            <version>5.2.23.RELEASE</version>
        </dependency>
        <!-- https://mvnrepository.com/artifact/org.springframework/spring-context -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>5.2.23.RELEASE</version>
        </dependency>

    </dependencies>

    <properties>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

</project>








Prepare a Java Project with the following files: AOPSpringPrj
Package: com.springcore
Main logic: Restaurant.java
MethodBeforeAdvisor: Java class: BeforeAdvisor.java
AfterReturningAdvice: AfterAdvisor.java
MethodInterceptor (AroundAdvice): AroundAdvisor.java
ThrowsAdvice : ThrowsAdvisor.java
Main Program: TestSpringProject.java
Spring Config file(under Resource ): Beans.xml
Put dependencies in pom.xml






package com.springcore;
import java.lang.reflect.Method;  
import org.springframework.aop.MethodBeforeAdvice;  
public class BeforeAdvisor implements MethodBeforeAdvice{  
    @Override  
    public void before(Method method, Object[] args, Object target)throws Throwable {  
        System.out.println("additional concern (Advertisements: Music) before actual logic");  
    }  
} 






package com.springcore;

import java.lang.reflect.Method;  
import org.springframework.aop.AfterReturningAdvice;  
public class AfterAdvisor implements AfterReturningAdvice{  
    @Override  
    public void afterReturning(Object returnValue, Method method,   Object[] args, Object target) throws Throwable {  
          System.out.println("additional concern (Vouchers for next order) after returning advice");  
    }  
  
} 







package com.springcore;
import org.aopalliance.intercept.MethodInterceptor;  
import org.aopalliance.intercept.MethodInvocation;  
public class AroundAdvisor implements MethodInterceptor{  
    @Override  
    public Object invoke(MethodInvocation mi) throws Throwable {  
        Object obj;  
        System.out.println("additional concern around (Menu items) before actual logic");  
        obj=mi.proceed();  
        System.out.println("additional concern around (Bills: take money) after actual logic");  
        return obj;  
    }  
 }





package com.springcore;

import org.springframework.aop.ThrowsAdvice;  
public class ThrowsAdvisor implements ThrowsAdvice{  
    public void afterThrowing(Exception ex){  
        System.out.println("additional concern (no booking ID: No entertainment: Send customer back ) if exception occurs");  
    }  
} 







Beans.xml:

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
	<bean id="restaurantBean" class="com.springcore.Restaurant" scope="singleton"
		init-method="init" destroy-method="destroy"></bean>
	<bean id="ba" class="com.springcore.BeforeAdvisor"></bean>
	<bean id="aa" class="com.springcore.AfterAdvisor"></bean>
    <bean id="ara" class="com.springcore.AroundAdvisor"></bean>
    <bean id="ta" class="com.springcore.ThrowsAdvisor"></bean>
	<bean id="proxy" class="org.springframework.aop.framework.ProxyFactoryBean">
		<property name="target" ref="restaurantBean"></property>
		<property name="interceptorNames">
			<list>
				<value>ba</value>	<value>aa</value>
				<value>ara</value>	<value>ta</value>
			</list>
		</property>
	</bean>
</beans>






package com.springcore;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.AbstractApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class TestSpringProject {
	public static void main(String[] args) {  
		ApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml");
		Restaurant restaurantObj = (Restaurant) context.getBean("proxy",Restaurant.class);
		System.out.println("RestaurantBean Initialised");
		((AbstractApplicationContext)context).registerShutdownHook();
		restaurantObj.greetCustomer(10);
	 }  
} 





Changed Main class: TestSpringProject:

package com.springcore;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.AbstractApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class TestSpringProject {
	public static void main(String[] args) {  
		ApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml");
		Restaurant restaurantObj = (Restaurant) context.getBean("proxy",Restaurant.class);
		System.out.println("RestaurantBean Initialised");
		((AbstractApplicationContext)context).registerShutdownHook();
		try{
		restaurantObj.greetCustomer(0);  }
		catch(Exception e)
		{ System.err.println(e);}
	}  
} 





package com.springcore;
public class Restaurant {
    public void greetCustomer(int booking) {
        	if(booking == 0)
    		throw new ArithmeticException();
   	System.out.println("Hello Customers");
    }
   public void init() {
      System.out.println("Restaurant Bean is going through init.");
   }
   public void destroy() {System.out.println("Bean will destroy now."); }
}

















